我觉得我已经完全无法进行debug了，我完全没法理解全部的代码了；我希望把这个任务给你，我现在有两个函数：
debug_tests/debug_test.py
image_processings/info.py


我希望通过这两个函数实现一个无监督的分割算法：
1.先用slic进行预处理，并得到一个超像素的分割，
image_processings/node.py当中定义了每个超像素的基本信息，他被当成图上的一个节点；

2.在这个超像素的基础上，通过颜色对超像素进行排序：
选择第一个超像素，在重心位置添加正提示点，选择百分之neg_pct的点位负提示点;
具体的细节可以参考image_processings/info.py当中的init；
此时，我们获取了初始的提示点，传入sam2，他会给我们一个mask，这个就是最开始的mask；

3.利用这个分割可以给每个超像素分配一个label：
如果一个超像素的内部logits.mean()超过0，那么这个超像素的label就是1；
未知的超像素label被初始化为-1了；
最开始设定好的负超像素的label为0；
在每一轮迭代中，我们要逐步将一些label为-1的超像素改为1；
label为0的超像素则在初始化时就已经全部确定了，不会再进行修改；

4.基于上一轮迭代，我们希望可以扩展预测的前景大小，以实现无监督分割的目的：
4.1
我对于全部label为1的超像素，由于我们把它当作了一个图，在info当中我们也是先了graph的代码，
因此我们可以找到label为1的节点全部label为-1的邻居，如果这个邻居是图像边缘的节点，我们就跳过这个节点：这样得到了全部的备选节点
选择logit最高的前三个备选节点，我们希望做三次实验，把这三个节点中最优的那个节点找到：
选择其中一个，将其label临时改为1，这时运行sam2得到mask的分数；我们选择分数最高的那一个，作为最好的超像素，将其label改为1，其他的两个点的label还是保持-1；

4.2
这时我们得到了一个新的正超像素，相当于扩大了前景；观察所有前景超像素构成的总区域，如果这个区域是一个高度非凸的区域，那么我们希望在这个区域上面取闭包增强：取这个非凸区域的闭包，然后再用闭包减去原始的正超像素区域，得到的区域我们去一个最大的连通分支，然后在这个连通分支的重心添加一个新的正提示点；
这时我们得到了一个正提示点的集合：全部的label为1超像素的重心，以及可能存在的一个凸包的提示点；

4.3 
最后我们得到了prompt：全部的提示点，以及mask构成的闭包；


然后我们把prompt送到sam2当中，就会又得到一个新的mask；这个mask再做为info的输入，更新全部的信息，循环往复；



以上是标准的流程，在实际的运行当中，更加需要添加一些配置，放入config文件：
1.在每轮运行时，到底是否需要取凸包，把这个当成一个开关
2.在每轮使用sam2的时候，对mask_prompt有几种可能：
2.1 完全不需要传入mask_prompt
2.2 需要传入mask_prompt，传入的是全部的label为1超像素，如果要取凸包，这里就也要取凸包
2.3 可能直接传入上一个sam2输出的low_resolution_mask当作提示
3. 到底是否需要选择logit最高的前三个备选节点做三次实验；这里的3其实是一个超参数n，我们要看一下n变化对原始问题的影响